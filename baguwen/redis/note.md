[note.md](https://github.com/gailunking/garen-store/files/14821862/note.md)[Uploadi# 模拟面试补充：

## redis是什么：

redis（remote dictionary server），是一种使用c语言编写的，高效的非关系型键值对数据库，与传统数据库不同，它将数据存储在内存中，所以读写速度非常快，被广泛应用于缓存方向。redis可以将数据写入磁盘中，保证了数据安全不丢失

## 优缺点：

#### 优点：

1. **基于****内存****的数据**库，速度非常快
2. 支持多种**数据结构**：string，list，set，zset，hash。
3. **支持事务**操作，可以将多个语句添加为一组指令集合，顺序执行
4. 提供了**持久化机制**，有aof日志与rdb内存快照两种持久化方式，各有优缺点
5. 可以**配备主**从，由主机向从机同步数据，实现读写分离
6. **单线程**操作，redis的命令都是单线程执行，6.0之后引入多线程，不过这个多线程是针对网络传输相关的多线程

#### 缺点：

1. 受制于物理内存限制，它的容量有限，所以只适合小数据量的存储情况
2. 结构化查询效果较差（如mysql可以select什么 从哪张表 where一堆条件然后连表啥的，但redis做不到这么复杂的查询）
3. 较难支持在线扩容

## redis为什么这么快？

- 基于内存
- IO多路复用技术，底层对多个连接进行一个轮询，非阻塞式
  - 有select poll epoll水平触发，边缘触发
- 高效的数据结构，数据结构在底层做了很多优化，存储读取很快

## redis分布式锁的潜在问题

 使用 `SETNX`（Set if Not eXists）命令实现的分布式锁是一种简单的实现方式，但也存在一些潜在的问题。以下是一些可能的问题：

1. **死锁****：** 如果获取锁的客户端在获取锁之后发生异常、崩溃或其他原因导致无法释放锁，就会出现死锁问题。为了解决这个问题，可以使用锁的自动超时机制，即为锁设置一个超时时间，一段时间后自动释放。
2. **非原子性释放：** 在释放锁的过程中，一般会使用Lua脚本确保释放锁的操作是原子性的。如果使用两个命令（比如`GET`和`DEL`）来分别检查和释放锁，由于这两个操作不是原子的，可能会导致在检查和释放之间，锁已经被其他客户端获取。
3. 锁覆盖： 如果多个客户端同时尝试获取相同的锁，其中一个可能会成功，而其他的都失败。这可能导致竞争条件，需要采用一些手段来确保公平性，如引入唯一标识符。
4. 时钟漂移： 分布式系统中的不同节点的时钟可能会存在漂移，这可能导致锁的超时时间不准确。为了解决这个问题，可以使用一些更复杂的算法，如基于时钟的算法或使用外部时间服务。
5. 锁续期问题： 如果获取锁的客户端需要执行一些复杂的业务逻辑，导致在锁未过期时锁已经被释放，这可能会导致其他客户端在不应该的情况下获取到锁。为了解决这个问题，可以使用锁续期机制，即在获取锁后，定期刷新锁的过期时间。
6. **不可重入性：** `SETNX` 基本上是一种互斥锁，不支持重入。如果同一个线程/进程尝试再次获取已经持有的锁，将会失败。如果需要支持重入，可以考虑使用带有标识符的锁。
7. 性能问题： 使用 `SETNX` 进行加锁操作的性能较差，因为它是单个命令。在高并发情况下，性能瓶颈可能出现在锁的获取和释放操作上。可以考虑使用更为复杂但性能更好的分布式锁实现，如基于 Redlock 算法的实现。

## redis中存在大key，删除时性能比较慢，有什么解决方法

一般来说我们定义大key，对于string类型大于512mb，或者list，set，zset，hash的成员数量多于10000就是大key。

1. 如果是String类型，可以考虑将其进行一个压缩，进行序列化或者反序列化的一个操作，或者是将大key进行拆分，比如list<order>进行拆分，分成不同的部分
2. 当value是其他集合类型时，进行一个分片操作，将不同的元素经过计算分到不同的片

## Redssion

[最强分布式工具Redisson(一):分布式锁 - 掘金](https://juejin.cn/post/6961380552519712798)

## 布隆过滤器原理？

## redis高可用性怎么保证的

集群模式，配备主从，哨兵机制

## redis数据类型相关

#### string：

底层SDS（动态简单字符串）

相比于语言，c语言字符串最后是个回车符标志结束，而sds有一个存储长度字段，判断是否结束，所以判断字符串长度的时间复杂度也是O（1）

存储的是二进制，所以不仅可以存储文本，也可以存储图片，视频等数据

不会造成缓存区溢出问题，是API安全的，拼接字符串时会判断空间是否足够，如果不够会动态扩容

#### redis批量修改数据

redis有一个管道功能，可以用管道进行批量操作

## Redis中**pipeline的作用？**

redis客户端执行一条命令分4个过程： **发送命令**、**命令排队**、**命令执行**、**返回结果**。使用`pipeline`可以批量请求，批量返回结果，执行速度比逐条执行要快。

使用`pipeline`组装的命令个数不能太多，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的`pipeline`命令完成。

原生批命令（mset和mget）与`pipeline`对比：

1. 原生批命令是原子性，`pipeline`是**非原子性**。pipeline命令中途异常退出，之前执行成功的命令**不会回滚**。
2. 原生批命令只有一个命令，但`pipeline`**支持多命令**。

## 针对热key进行什么处理

1. 缓存预热，提前加载热一些热key到缓存中
2. 集群分布，将热key放在不同的机器上做负载均衡
3. 缓存时间合理设置，不要太短或者让热key集中过期之类的，会造成缓存击穿，均匀设置过期时间
4. 使用管道流水线pipeline操作或事务减少与redis连接通信次数

## redis部署

#### 主从：

#### 哨兵

#### cluster集群：

redis集群配置，也就是cluster，它是通过配备多个redis节点，用来使redis达到高可用性，一般最少配备6台机器，三主三从，主节点负责读写，从节点只负责同步数据进行主从故障转移。16383

**优点：**

1.  去中心化，支持动态扩容
2. 高可用性，节点平分槽位

**缺点：**

1. 不支持批量操作（pipeline）
2. 只能使用一个数据库，0号
3. 数据异步复制，不能保证强一致性
4. 事务操作有限，只能对同一节点的指令进行事务操作

## 潼哥笔记问题整合：

1. ##### redis较难支持在线扩容，什么是在线扩容，为什么它难支持

1. ##### 多线程和单线程是个什么情况

1. ##### IO多路复用是个什么东西，事件又是什么？

1. ##### 大集合key分片怎么处理

**redis大key分片是什么**

ChatGPT

在 Redis 中，"大 Key" 是指占用较大内存空间的键，这可能会导致一些性能问题，尤其是在数据集较大时。为了解决这个问题，可以使用大 Key 分片的技术。

大 Key 分片是一种将大 Key 拆分成多个小 Key 的策略，从而减小单个键的大小，提高性能。这通常是通过将大的数据结构，比如大的哈希表、集合或列表，分割成多个小的数据结构来实现的。

例如，假设有一个大的哈希表键 "user:info"，存储了用户的详细信息。如果这个哈希表非常大，可以考虑将其拆分成多个小的哈希表，每个小哈希表对应一个用户，键可以设计成 "user:info:userid"。

这样做的好处有几点：

1. 减小单个键的内存占用： 将大 Key 拆分成小 Key 可以减小单个键占用的内存空间，提高 Redis 的性能。
2. 提高并发性： 在多个小 Key 上进行操作，可以提高并发性，减小锁的竞争，提高系统的整体性能。
3. 更好的内存管理： Redis 对于小的键值对的管理效率更高。当数据量很大时，使用大 Key 可能导致内存碎片等问题，而分片可以更好地管理内存。

需要注意的是，大 Key 分片需要根据具体的业务场景和数据模型来设计。在实践中，需要权衡性能和数据模型的复杂性，并根据实际情况来选择是否采用大 Key 分片。

You

**所以说 它的分片不是指分到不同的redis机器，而是分到不同的数据集合中**

ChatGPT

是的，你理解得正确。在这里提到的大 Key 分片并不涉及将数据分散到不同的 Redis 实例（机器）上，而是将大的数据结构（例如大的哈希表、集合或列表）分割成多个小的数据结构，这些小的数据结构存在于同一个 Redis 实例中，但是在键的层面上有一些结构化的划分。

这种分片是在 Redis 实例内部进行的，目的是更好地管理内存、提高性能、减小单个键的内存占用以及提高并发性。这样可以更好地适应 Redis 单实例的特性，而不涉及多实例之间的数据划分和同步。

如果需要横向扩展，即将数据分散到多个 Redis 实例（机器）上，通常会使用分布式缓存或数据分片的方法，这涉及到多个 Redis 节点之间的数据同步和管理。而在这里提到的大 Key 分片，主要是为了优化单个 Redis 实例内的性能。ng note.md…]()
